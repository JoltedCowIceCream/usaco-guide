---
id: usaco-895
source: USACO Silver 2019 January
title: Icy Perimeter
author: Tanish Tyagi, Brad Ma, Juheon Rhee, David Guo
---

[Official Analysis (C++)](http://www.usaco.org/current/data/sol_perimeter_silver_jan19.html)

## Explanation

We can use Breadth-First Search (BFS) to explore each blob, starting from an unvisited '#' cell. During BFS, we can calculate the blobâ€™s area by counting the number of '#' cells visited and determine its perimeter by counting the number of adjacent cells, reducing the count for each shared edge with neighboring '#' cells. As we traverse the grid, we can initiate a BFS for each unvisited '#' cell to compute the area and perimeter of all blobs. We can track the largest area found, and if multiple blobs share the same largest area, we can choose the one with the smallest perimeter. Finally, we output the largest area and the corresponding smallest perimeter.

## Implementation

**Time Complexity:** $\mathcal{O}(N^2)$

<LanguageSection>

<JavaSection>

```java
import java.io.*;
import java.util.*;

public class IcyPerimeter {
    static int n;
    static char[][] grid;
    static boolean[][] visited;
    static final int[][] directions = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}}; // Movement directions (up, down, left, right)

    // BFS function to calculate the area and perimeter of a blob of ice cream
    static int[] bfs(int x, int y) {
        Queue<int[]> q = new LinkedList<>();
        q.add(new int[]{x, y}); // Start BFS from the given cell (start_x, start_y)

        int area = 0;
        int perimeter = 0;

        while (!q.isEmpty()) {
            int[] cur = q.poll();
            int cur_x = cur[0], cur_y = cur[1]; // Current cell

            // Skip if the cell has already been visited
            if (visited[cur_x][cur_y]) {
                continue;
            }

            visited[cur_x][cur_y] = true; // Mark the cell as visited
            area++; // Increment area (each '#' contributes 1 to the area)

            int sides = 4; // Each cell starts with 4 sides contributing to the perimeter
            for (int[] dir : directions) {
                int new_x = cur_x + dir[0], new_y = cur_y + dir[1];

                // Check if the neighboring cell is within the grid
                if (new_x >= 0 && new_x < n && new_y >= 0 && new_y < n) {
                    if (grid[new_x][new_y] == '#') { // If the neighbor is part of the same blob
                        q.add(new int[]{new_x, new_y}); // Add the neighbor to the queue
                        sides--; // Shared edges reduce the perimeter contribution
                    }
                }
            }
            perimeter += sides; // Add remaining sides to the perimeter
        }

        return new int[]{area, perimeter};
    }

    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new FileReader("perimeter.in"));
        PrintWriter pw = new PrintWriter(new FileWriter("perimeter.out"));

        n = Integer.parseInt(br.readLine());
        grid = new char[n][n];
        visited = new boolean[n][n];

        for (int i = 0; i < n; i++) {
            grid[i] = br.readLine().toCharArray();
        }

        int max_area = 0;
        int min_perimeter = Integer.MAX_VALUE;

        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                if (grid[i][j] == '#' && !visited[i][j]) {
                    int[] result = bfs(i, j);
                    int area = result[0];
                    int perimeter = result[1];

                    // Update max_area and min_perimeter based on the BFS results
                    if (area > max_area || (area == max_area && perimeter < min_perimeter)) {
                        max_area = area;
                        min_perimeter = perimeter;
                    }
                }
            }
        }

        pw.println(max_area + " " + min_perimeter);
        pw.close();
    }
}
```

</JavaSection>

<CPPSection>

```cpp
#include <bits/stdc++.h>
using namespace std;

int n;
vector<vector<char>> grid;
vector<vector<bool>> visited;
const vector<pair<int, int>> directions = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}}; // Movement directions (up, down, left, right)

// BFS function to calculate the area and perimeter of a blob of ice cream
pair<int, int> bfs(int x, int y) {
    queue<pair<int, int>> q;
    q.push({x, y}); // Start BFS from the given cell (start_x, start_y)
    
    int area = 0;
    int perimeter = 0;

    while (!q.empty()) {
        auto [cur_x, cur_y] = q.front(); // Current cell
        q.pop();

        // Skip if the cell has already been visited
        if (visited[cur_x][cur_y]) {
            continue;
        }
        
        visited[cur_x][cur_y] = true; // Mark the cell as visited
        area++; // Increment area (each '#' contributes 1 to the area)

        int sides = 4; // Each cell starts with 4 sides contributing to the perimeter
        for (auto [dx, dy] : directions) {
            int new_x = cur_x + dx, new_y = cur_y + dy;

            // Check if the neighboring cell is within the grid
            if (new_x >= 0 && new_x < n && new_y >= 0 && new_y < n) {
                if (grid[new_x][new_y] == '#') { // If the neighbor is part of the same blob
                    q.push({new_x, new_y}); // Add the neighbor to the queue
                    sides--; // Shared edges reduce the perimeter contribution
                }
            }
        }
        perimeter += sides; // Add remaining sides to the perimeter
    }

    return {area, perimeter};
}

int main() {
    freopen("perimeter.in", "r", stdin);
    freopen("perimeter.out", "w", stdout);

    cin >> n;

    grid.resize(n, vector<char>(n));
    visited.assign(n, vector<bool>(n, false));

    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            cin >> grid[i][j];
        }
    }

    int max_area = 0;
    int min_perimeter = INT_MAX;

    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            if (grid[i][j] == '#' && !visited[i][j]) {
                auto [area, perimeter] = bfs(i, j);
                // Update max_area and min_perimeter based on the BFS results
                if (area > max_area || (area == max_area && perimeter < min_perimeter)) {
                    max_area = area;
                    min_perimeter = perimeter;
                }
            }
        }
    }

    cout << max_area << " " << min_perimeter << "\n";
    return 0;
}
```

</CPPSection>

<PySection>

```py

from collections import deque

n = 0
grid = []
visited = []
directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]  # Movement directions (up, down, left, right)

# BFS function to calculate the area and perimeter of a blob of ice cream
def bfs(x, y):
    q = deque()
    q.append((x, y))  # Start BFS from the given cell (start_x, start_y)
    
    area = 0
    perimeter = 0

    while q:
        cur_x, cur_y = q.popleft()  # Current cell

        # Skip if the cell has already been visited
        if visited[cur_x][cur_y]:
            continue
        
        visited[cur_x][cur_y] = True  # Mark the cell as visited
        area += 1  # Increment area (each '#' contributes 1 to the area)

        sides = 4  # Each cell starts with 4 sides contributing to the perimeter
        for dx, dy in directions:
            new_x, new_y = cur_x + dx, cur_y + dy

            # Check if the neighboring cell is within the grid
            if 0 <= new_x < n and 0 <= new_y < n:
                if grid[new_x][new_y] == '#':  # If the neighbor is part of the same blob
                    q.append((new_x, new_y))  # Add the neighbor to the queue
                    sides -= 1  # Shared edges reduce the perimeter contribution
        
        perimeter += sides  # Add remaining sides to the perimeter

    return area, perimeter

# Main function
if __name__ == "__main__":
    with open("perimeter.in", "r") as f:
        n = int(f.readline().strip())
        grid = [list(f.readline().strip()) for _ in range(n)]
        visited = [[False] * n for _ in range(n)]

    max_area = 0
    min_perimeter = float('inf')

    for i in range(n):
        for j in range(n):
            if grid[i][j] == '#' and not visited[i][j]:
                area, perimeter = bfs(i, j)
                # Update max_area and min_perimeter based on the BFS results
                if area > max_area or (area == max_area and perimeter < min_perimeter):
                    max_area = area
                    min_perimeter = perimeter

    with open("perimeter.out", "w") as f:
        f.write(f"{max_area} {min_perimeter}\n")
```
</PySection>

</LanguageSection>
